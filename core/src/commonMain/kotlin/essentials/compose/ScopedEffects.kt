package essentials.compose

import androidx.compose.runtime.*
import essentials.*
import essentials.coroutines.*
import injekt.*
import kotlinx.coroutines.*

@Composable inline fun scopedAction(
  scope: Scope<*> = inject,
  crossinline block: suspend () -> Unit
): () -> Unit = action(implicitly(), block)

@Composable inline fun <P1> scopedAction(
  scope: Scope<*> = inject,
  crossinline block: suspend (P1) -> Unit
): (P1) -> Unit = action(implicitly(), block)

@Composable inline fun <P1, P2> scopedAction(
  scope: Scope<*> = inject,
  crossinline block: suspend (P1, P2) -> Unit
): (P1, P2) -> Unit = action(implicitly(), block)

@Composable inline fun <P1, P2, P3> scopedAction(
  scope: Scope<*> = inject,
  crossinline block: suspend (P1, P2, P3) -> Unit
): (P1, P2, P3) -> Unit = action(implicitly(), block)

@Composable inline fun <P1, P2, P3, P4> scopedAction(
  scope: Scope<*> = inject,
  crossinline block: suspend (P1, P2, P3, P4) -> Unit
): (P1, P2, P3, P4) -> Unit = action(implicitly(), block)

@Composable inline fun <P1, P2, P3, P4, P5> scopedAction(
  scope: Scope<*> = inject,
  crossinline block: suspend (P1, P2, P3, P4, P5) -> Unit
): (P1, P2, P3, P4, P5) -> Unit = action(implicitly(), block)

@Composable fun LaunchedScopedEffect(
  vararg keys: Any?,
  scope: Scope<*> = inject,
  block: suspend (@Provide CoroutineScope) -> Unit
) {
  rememberScoped(keys = keys) {
    object : RememberObserver {
      private var job: Job? = null

      override fun onRemembered() {
        job = launch(
          // TODO REMOVE EXPLICIT PASSING ONCE WE FIGURED OUT THAT NASTY INJEKT BUG
          scope = CoroutineScopeProviders.scopeCoroutineScope(scope),
          block = block
        )
      }

      override fun onForgotten() {
        job?.cancel()
        job = null
      }

      override fun onAbandoned() {
        job?.cancel()
        job = null
      }
    }
  }
}

@Composable fun <T : Any> rememberScoped(
  vararg keys: Any?,
  scope: Scope<*> = inject,
  key: String? = null,
  init: () -> T,
): T {
  val compositeKey = currentCompositeKeyHash
  // key is the one provided by the user or the one generated by the compose runtime
  val finalKey = if (!key.isNullOrEmpty()) key
  else compositeKey.toString(36)
  val holder = remember(scope, finalKey) { scope.scoped(finalKey) { ScopedHolder() } }

  val value = (holder.value
    .takeIf { it !== Uninitialized && keys.contentEquals(holder.keys) }
    ?: init().also { holder.updateValue(it, keys) })
    .unsafeCast<T>()

  SideEffect {
    if (!holder.rememberedValue) {
      holder.rememberedValue = true
      value.safeAs<RememberObserver>()?.onRemembered()
    }
  }

  return value
}

private class ScopedHolder : DisposableHandle {
  var value: Any? = Uninitialized
  var keys: Array<out Any?>? = null
  var rememberedValue = false

  override fun dispose() {
    updateValue(Uninitialized, null)
  }

  fun updateValue(newValue: Any?, newKeys: Array<out Any?>?) {
    value.safeAs<DisposableHandle>()?.dispose()
    value.safeAs<RememberObserver>()?.onForgotten()
    rememberedValue = false
    value = newValue
    keys = newKeys
  }
}

private val Uninitialized = Any()
